## 整数替换

初看感觉题目简单，直接除下去，发现了许多坑

遇到的问题
1. 需要考虑替换后的整数是否为奇数(没有看清题目)
2. 时间运行的问题(直接迭代替换，完全跑不动)

主要问题：
在于整个计算的时间复杂度较高，耗费遇到奇数的计算上

位运算思路
``` c++
/**
 * 二进制观察处理法
 * 实现思路:
 *      最快的移动就是遇到2的次幂(例如数字16  10000 -> 01000 -> 00100 -> 00010 -> 00001)
 *      将二进制一直左移 最右为0时可以直接移动(例如数字6  000110 -> 000011)
 *      最右位为1时需把1变成0, 再移动(例如数字9  001001 -> 001000)
 *      故最优解就是如何在迭代中减少出现末尾1(就是什么时候+1, 什么时候-1 来实现过程中最少出现01或11结尾)
 * 得出以下结论:
 *      若n的二进制为 xxxx10, 则下一次处理 n = n/2 次数+1
 *      若n的二进制为 xxxx01, 则下一次处理 n = n/2 次数+2(即需要先-1再除以2, 故这里是加2) n > 1
 *      若n的二进制为 xxxx11, 则下一次处理 n = n/2 +1 次数+2(即需要先+1再除以2, 故这里是加2) n > 3
 *      特殊情况: 数字3  000011, 000011 -> 000010 -> 000001(两次即可)
 * 边界条件: 000001 -> 答案为0
 */
```