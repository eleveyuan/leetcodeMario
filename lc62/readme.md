## 不同路径

从起点到终点，只能向右或向下。

第一个想法就是递归，当前节点到达一下个节点可能性，这个题目的遍历就像二叉树遍历一样，只有两个方向

同时随着写递归的时候，推理发现，**只要到达任一列最下或者任一行最右，就相当于到达了终点**。只需要在意内部变化即可

使用递归62个测试用例，过到第41个就超时了

所以需要考虑新的了方法了，由于前面的经验，到达边界就已经到达终点，所以我们可像剥洋葱一样，一层层的去掉边界，去获取小一层的空间，这样可以看出可以用**动态规划**求解问题呢

状态转移函数(从递归的函数可以看出)：
L(n, m) = L(n-1, m) + L(n, m-1)

这是一个二维的动态规划，使用一个二维数组存储中间状态。

处理的细节：
1. 因为单一行，或单一列，到达终点路径只有一条，所以原始存第一行第一列都是的路径数为1，然后开始累加计算。(可以试着画图推一下)
2. 如果从下标零开始，因为计算n-1以及m-1会越界，需要从1开始。

**注意**
动态申请数组，存储在堆空间

C++中一般是不能使用**变量**作为一个数组的长度的，必须使用常量。

这是因为数组作为C++的内置数据类型，其空间分配在**栈内存**中，这部分空间的大小在编译时就要确定，不能等到运行时再分配。常量的值在编译时就能得到，而变量的值在运行时才能确定。
